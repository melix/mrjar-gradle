plugins {
   id 'java-library'
}

java {
   toolchain {
      languageVersion.set(JavaLanguageVersion.of(8))
   }
}

sourceSets {
   java11 {
      java {
       srcDirs = ['src/main/java11']
      }
   }
}

dependencies {
    // This is only necessary because in real life, we have dependencies between classes
    // and what you're likely to want to do, is to provide a JDK 9 specific class, which depends on common
    // classes of the main source set. In other words, you want to override some specific classes, but they
    // still have dependencies onto other classes.
    // We want to avoid recompiling all those classes, so we're just saying that the Java 9 specific classes
    // "depend on" the main ones.
    java11Implementation files(sourceSets.main.output.classesDirs)
}

tasks.named('compileJava11Java') {
   javaCompiler = javaToolchains.compilerFor {
      languageVersion = JavaLanguageVersion.of(11)
   }
}

jar {
   into('META-INF/versions/11') {
      from sourceSets.java11.output
   }
   manifest.attributes(
      'Multi-Release': 'true', 
      'Main-Class': 'com.acme.JdkSpecific'
   )
}

// You might wonder why not use the `application` plugin here?
// Well it's easy: it doesn't build the jar (because it doesn't have to,
// it can use the class directory instead), so since it's not a jar, multi-release is not seen!
// Another good reason not to use MRJars!
task run(type: JavaExec) {
   dependsOn jar
   classpath files(jar.archivePath)
   main = 'com.acme.JdkSpecific'
}

